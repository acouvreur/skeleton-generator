{"name":"Skeleton Generator Project","tagline":"The Skeleton Software Community","body":"## About model driven development\r\nMuch has been written about the MDD. It would be useless and tedious to give you a comprehensive list of its benefits and pitfalls.\r\nThe skeleton-generator project uses an original approach : whereas most of MDD tools are based on a UML representation of the domain model, we use a XML representation of a Database schema with additional metadata.\r\n\r\n## Our domain model representation\r\nIn our different application skeletons, the domain model comes in three different ways :\r\n* In the database\r\n* In the business objects that are handled by services\r\n* In the presentation layer where we use the MVC pattern with \"easy to bind\" objects.\r\nEach of these layers use a different projection of the domain model and need additional metadata to manage it properly.\r\nWe have chosen to fully represent them the way we would represent a database in a single XML file.\r\nWe systematically use a \"one business object - one table\" pattern. the additional metadata we add should allow to describe :\r\n* The relationships between objects\r\n* The behaviour of objects with respect to other related objects\r\n* The way objects will be handled in the UI (if there is one).\r\nThis XML file will take its place in your SCM the most natural way !\r\n\r\n## Raise productivity...\r\nCode generation is one the main axes on which \"high productivity\" frameworks are based. We don't have the ambition to provide such a framework. We simply use popular open source Java frameworks such as Hibernate, Spring,... and put them together so as to build a coherent skeleton that developers can rely on. This way, we can help you save time when setting up your project, produce and assemble your different layers and expose basic services.\r\n## Improve quality...\r\nWe have the ambition to help you produce high quality and sustainable code. The skeletons we generate rely on design patterns with accordance to Java standards. We have spent a lot of time (and will keep spending a lot of time) studying the official documentations of the frameworks we use to meet best practices.\r\n\r\n## ...keep flexibility !\r\nOne of the major advantages of our approach is that you can still use those popular, widespread and well documented Java frameworks without needing to spend a lot of time learning one or another. But more important, you will keep the flexibility of those frameworks : even if some \"high productivity\" are based on the same frameworks (such as Grails), it can be a pain when you really need to disturb the piping. In our case, you have a full access to the pipe !\r\nThe point is : how to evolve our domain model without breaking what we have rewritten ? We simply have a commentary header that tells you whether you can edit or not a file. When you can edit a file, we use tags to tell the generator not to overwrite what is inside as well as it will take care of your java imports...\r\nThe design patterns we use enable you to specialize your code by overriding some functions, or simply by enriching the classes or interfaces behaviour. We also strongly recommend aspect oriented programming to make things even more sustainable. Sure you will be astonished to see how generated and non-generated code can live together in harmony !\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}